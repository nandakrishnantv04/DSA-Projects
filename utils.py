# -*- coding: utf-8 -*-
"""Python Utilities
Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_FVXtDtK-U0_E7F42733VynoFCebC8mI
"""
# utils.py

import pandas as pd
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline, make_pipeline
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.metrics import roc_auc_score, classification_report, confusion_matrix

def create_preprocessor():
    """
    Creates and returns the ColumnTransformer pipeline for data preprocessing.
    This ensures that the same transformations are applied during training and prediction.
    """
    numerical_features = ['tenure', 'MonthlyCharges', 'TotalCharges']
    categorical_features = ['gender', 'SeniorCitizen', 'Partner', 'Dependents',
                            'PhoneService', 'MultipleLines', 'InternetService',
                            'OnlineSecurity', 'OnlineBackup', 'DeviceProtection',
                            'TechSupport', 'StreamingTV', 'StreamingMovies',
                            'Contract', 'PaperlessBilling', 'PaymentMethod']

    # 1. Preprocessing Transformers
    numeric_transformer = make_pipeline(StandardScaler())

    # OneHotEncoder is the best way to handle the categorical features
    categorical_transformer = make_pipeline(OneHotEncoder(handle_unknown='ignore', sparse_output=False))

    # 2. Combine transformers into a ColumnTransformer
    preprocessor = ColumnTransformer(
        transformers=[
            ('num', numeric_transformer, numerical_features),
            ('cat', categorical_transformer, categorical_features)
        ],
        remainder='drop'
    )
    return preprocessor

def get_models():
    """Returns a dictionary of models to be trained."""
    return {
        'Logistic Regression': LogisticRegression(solver='liblinear', random_state=42, class_weight='balanced'),
        'Random Forest': RandomForestClassifier(n_estimators=100, random_state=42, class_weight='balanced'),
        'Gradient Boosting': GradientBoostingClassifier(n_estimators=100, learning_rate=0.1, random_state=42)
    }

def evaluate_model(y_test, y_proba, y_pred, model_name):
    """Calculates and returns key evaluation metrics."""
    return {
        'Model': model_name,
        'AUC Score': roc_auc_score(y_test, y_proba),
        'Classification Report': classification_report(y_test, y_pred, output_dict=True),
        'Confusion Matrix': confusion_matrix(y_test, y_pred)
    }